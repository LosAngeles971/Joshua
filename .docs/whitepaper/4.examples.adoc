== Other problems

This chapter shows other problems which highlight some interesting aspects about how Joshua works.

=== The heritage

[quote, anonymous]
____
A person gets an heritage of 1024â‚¬, and it starts spending half of the amount each day. How many days does he take to stay with less than 1 euro?
____

A simple mathematical problem that can be easily described by three events:

* "He has less than 1 euro" is the solution event;
* "One day of spending"
* "The inheritance is halved"

[source, yaml]
----
  knowlegde:
    - id: "One day of spending"
      conditions:
        - Inheritance > 1.0
      effects:
        - weight: 1.0
          event: "The inheritance is halved"
        - weight: 0.5
          event: "He has less than 1 euro"

    - id: "The inheritance is halved"
      effects:
        - weight: 0.5
          event: "He has less than 1 euro"
      assignments:
        - Inheritance = Inheritance / 2

    - id: "He has less than 1 euro"
      conditions:
        - Inheritance < 1.0
----

In this problem there is an always true cause-effect, indeed if you have "one day of spending", surely your inheritance will be halved.

Finally, the state only contains only the variable "Inheritance", with an initiali value of _1024: at the beginning of the problem.


[source, bash]
----
joshua.exe solve -k k_euro.yml -p p_euro.yml    
Max cycles:  100
State contains:  1  variables
        Outcome|   true|
         Cycles|     10|
   Queue's size|     12|
----

=== The water containers

[quote, anonymous]
____
There are three containers A, B, C. 
A can hold a maximum of 3 litres of water, and it is empty. 
B can hold a maximum of 5 litres of water, and it is empty. 
C can hold a maximum of 8 litres of water, and it is full. 
There are no marks on the containers. 
You need to have at least one of B or C with 4 litres of water, how can you do that?
____

This problem is really similar to that of the _Farmer_. Describing the events essentially means listing all possibile actions, as well as every action can potentially (not surely) causes the solution's effect.

[source, yaml]
----
  knowlegde:
    - id: "Empty C in A"
      conditions:
        - C > 0
      effects:
        - weight: 0.5
          event: "B or C contains 4"
      assignments:
        - DeltaA = MaxA - A
        - SubC = min(C, DeltaA)
        - C = C - SubC
        - A = A + SubC

    - id: "Empty C in B"
      conditions:
        - C > 0
      effects:
        - weight: 0.5
          event: "B or C contains 4"
      assignments:
        - DeltaB = MaxB - B
        - SubC = min(C, DeltaB)
        - C = C - SubC
        - B = B + SubC

    - id: "Empty A in B"
      conditions:
        - A > 0
      effects:
        - weight: 0.5
          event: "B or C contains 4"
      assignments:
        - DeltaB = MaxB - B
        - SubA = min(A, DeltaB)
        - A = A - SubA
        - B = B + SubA

    - id: "Empty A in C"
      conditions:
        - A > 0
      effects:
        - weight: 0.5
          event: "B or C contains 4"
      assignments:
        - DeltaC = MaxC - C
        - SubA = min(A, DeltaC)
        - A = A - SubA
        - C = C + SubA        

    - id: "Empty B in A"
      conditions:
        - B > 0
      effects:
        - weight: 0.5
          event: "B or C contains 4"
      assignments:
        - DeltaA = MaxA - A
        - SubB = min(B, DeltaA)
        - B = B - SubB
        - A = A + SubB

    - id: "Empty B in C"
      conditions:
        - B > 0
      effects:
        - weight: 0.5
          event: "B or C contains 4"
      assignments:
        - DeltaC = MaxC - C
        - SubB = min(B, DeltaC)
        - B = B - SubB
        - C = C + SubC

    - id: "B or C contains 4"
      conditions:
        - B == 4 || C == 4
----

Unlike the _Farmer's_ problem, here the assignments are not trivial but tricky, because their definition may look like anticipating reasoning to Joshua. Such consideration is also visible into the problem definition file.

[source, yaml]
----
  variables:
    - name: A
      value: 0
      defined: true
    - name: B
      value: 0
      defined: true
    - name: C
      value: 8
      defined: true
    - name: MaxA
      value: 3
      defined: true
    - name: MaxB
      value: 5
      defined: true
    - name: MaxC
      value: 8
      defined: true
    - name: DeltaA
      value: 0
      defined: true
    - name: DeltaB
      value: 0
      defined: true
    - name: DeltaC
      value: 0
      defined: true
    - name: SubA
      value: 0
      defined: true
    - name: SubB
      value: 0
      defined: true
    - name: SubC
      value: 0
      defined: true
  success: "B or C contains 4"
----

As you can see, beyond the obvious variables (A, B, C, D) about the amount of water into the containers, there are other variables useful only for temporary calculations.

Likewise the _Farmer's_ problem, there is trial-and-error approach.

[source, bash]
----
joshua.exe solve -k k_acqua.yml -p p_acqua.yml
Max cycles:  100
State contains:  12  variables
        Outcome|   true|
         Cycles|     49|
   Queue's size|     55
----


image::./images/water.svg[]


=== Flights and pilots

[quote, anonymous]
____
Carlo, Bruno and Alberto work in the same team. One is the pilot, one is the copilot, and one is the engineer.
The copilot does not have sisters and brothers, and he earns the least of all.
Carlo is the husband of the Bruno's sister, and he earns more than the pilot.
Can you say the job of everyone?
____

Solving this problem requires few and simple logic steps:

* Bruno cannot be the copilot, because he got a sister.
* Carlo is the Engineer, since he earns more than the pilot and the copilot earns the least.
* Bruno is pilot.
* Alberto is the copilot.

Even if solving this problem is trivial for a human, it requires a lot from Joshua, since it requires the ability to handle the logic, and the _reductio ad absurdum_.

For example, the statement "Carlo is the Engineer, since he earns more than the pilot and the copilot earns the least." derives not from a comparison of values (the wage of Carlo), but from the application of logic.

Carlo earns more then pilot -> Carlo is not the pilot
Copilot earns the least of all -> (Pilot earns more than copilot & Engineer earns more then copilot)


.... genetic algorithms .....
TBD


