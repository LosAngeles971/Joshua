= Joshua

LosAngeles971, 2021

:sectnums!:

== Joshua

**Joshua** is a software inspired by a book footnote:[Incoscienza Artificiale - Massimo Chiriatti - https://www.ibs.it/incoscienza-artificiale-come-fanno-macchine-libro-massimo-chiriatti/e/9788861056312?inventoryId=275963946] to solve **problems** using a combination of **knowledge** and **state**.

The _knowledge_ consists of **events** and **relationships** between events.

An _event_ is _something_ that occurs under certain circumstances described by a _state_; for example the event "the farmer reaches the est bank of the river" can occur if the farmer is not on the est bank of the river.

The _state_ includes information which determine if events may happen or not,  as well as the occurrence of events may change the _state_.

Finally, the _relationships_ tie events by means of **cause-effect** principle, thus the occurrence of an event may cause the occurrence of other events.

How can Joshua solve a problem?::
A _problem_ is described as the combination of (i) the _knowledge_, (ii) an initial _state_ and (iii) a _final event_, the latter is the event you would check the occurrence.

In these terms, finding a solution for a problem means checking if there is **at least one chain of events that eventually cause the final event**.

Joshua can have different applications, and it can be view as a simple _rule engine_.

:sectnums:

<<<
== The farmer, the wolf, the goat and the cabbage

[quote, https://en.wikipedia.org/wiki/Wolf,_goat_and_cabbage_problem]
____
Once upon a time a farmer went to a market and purchased a wolf, a goat, and a cabbage. On his way home, the farmer came to the bank of a river and rented a boat. But crossing the river by boat, the farmer could carry only himself and a single one of his purchases: the wolf, the goat, or the cabbage.
If left unattended together, the wolf would eat the goat, or the goat would eat the cabbage.
The farmer's challenge was to carry himself and his purchases to the far bank of the river, leaving each purchase intact. How did he do it?
____

From the perspective of Joshua, a problem combination of (i) the _knowledge_, (ii) an initial _state_ and (iii) a _final event_, the latter is the event you would check the occurrence. Finding a solution for a problem means checking if there is **at least one chain of events that eventually cause the final event**.

An event is something like a phisycal phenomena or an action, and formally is defined by the following elements:
. a unique name
. a list of conditions
. an _optional_ list of assignments
. an _optional_ list of effects

Each _condition_ is a mathematical expression which returns a boolean value; thus if all conditions are true, then the event occurs and the consequences are in the form of _assignments_ and _effects_.

Each _assignment_ is a mathematical expression to assign a value to a _variable_. 

Each _effect_ is the representation of a **cause-effect relationship** between events, formally it is a **weighted" link to another event and the _weight_ characterizes the nature of the relationship:

* 0.0 means the cause **never** triggers the effect
* 1.0 means the cause **always** triggers the effect
* any value into (0,1) means that the cause _may_ trigger the effect

Thus the weight indicates how much the effect is likely to occur once the cause occurred. For example the event "The farmer brings the cabbage on the bank B of the river" _may_ cause the effect "The farmer, the wolf, the goat and the cabbage are on the bank B of the river", but it not sure, so the weight of such relationship must be into (0,1).

The _state_ plays a central role in the occurrence of events, since it includes the information which determine if an event may happen or not; such information are in the forms of **variables** and indeed:

* event's conditions refers to the variables of the **current state**
* event's assignments updates the variables of the **curren state** to determine the **new state**

Trying to solve the the farmer's problem_ requires to define:

. a state and its initial value
. a final event
. a knowledge

About defining the state, a possible approach sees 4 variables to determine, over the time, if the involced characters (farmer, woklf, goat and cabbage) are on est (1) or ovest (0) bank of the river.

The initial state is all characters on the ovest bank of the river:

* Farmer_location   = 1
* Wolf_location     = 1
* Goat_location     = 1
* Cabbage_location  = 1

The final evet is "They are all on the est bank of the river".

Finally the knowledge is simply a list of events, and it can be designed by means of Joshua's language using a approach like the following:

. identification of the final event (aka the problem's solution)
. identification of the chains of events which eventually cause the final event
. desisgn the cause-effect relationships between all events
. design conditions and assignments for each event

Below a knowledge to solve the _farmer's problem_.

[source]
----
/*
The farmer, the wolf, the goat and the cabbage
*/

  event(They are all on the est bank of the river) {
	if {
	  "Farmer_location == 1"
	  "Wolf_location == 1"
	  "Goat_location == 1"
	  "Cabbage_location == 1"
	}
	then {
	}
    effects {
    }
  }
  
  event(The farmer brings the cabbage to the est bank of the river) {
	if {
	  "Farmer_location == 0"
	  "Cabbage_location == 0"
	  "Wolf_location != Goat_location"
	}
	then {
	  "Farmer_location = 1"
	  "Cabbage_location = 1"
	}
    effects {
        ("They are all on the est bank of the river", 0.5)
    }
  }
  
  event(The farmer brings the cabbage to the ovest bank of the river) {
	if {
	  "Farmer_location == 1"
	  "Cabbage_location == 1"
	  "Wolf_location != Goat_location"
	}
	then {
	  "Farmer_location = 0"
	  "Cabbage_location = 0"
	}
    effects {
        ("They are all on the est bank of the river", 0.1)
    }
  }
  
  event(The farmer brings the goat to the est bank of the river) {
	if {
		"Farmer_location == 0"
		"Goat_location == 0"
	}
	then {
	  "Farmer_location = 1"
	  "Goat_location = 1"
	}
    effects {
        ("They are all on the est bank of the river", 0.5)
    }
  }
  
  event(The farmer brings the goat to the ovest bank of the river) {
	if {
		"Farmer_location == 1"
		"Goat_location == 1"
	}
	then {
	  "Farmer_location = 0"
	  "Goat_location = 0"
	}
    effects {
        ("They are all on the est bank of the river", 0.1)
    }
  }
  
  event(The farmer brings the wolf to the est bank of the river) {
	if {
		"Farmer_location == 0"
		"Wolf_location == 0"
		"Cabbage_location != Goat_location"
	}
	then {
	  "Farmer_location = 1"
	  "Wolf_location = 1"
	}
    effects {
        ("They are all on the est bank of the river", 0.5)
    }
  }
  
  event(The farmer brings the wolf to the ovest bank of the river) {
	if {
		"Farmer_location == 1"
		"Goat_location == 1"
		"Cabbage_location != Goat_location"
	}
	then {
	  "Farmer_location = 0"
	  "Wolf_location = 0"
	}
    effects {
        ("They are all on the est bank of the river", 0.1)
    }
  }
  
  event(The farmer goes to the est bank of the river) {
	if {
	  "Farmer_location == 0"
	  "(Wolf_location == 1 && Cabbage_location == 1 && Goat_location == 0) ||
	  (Wolf_location == 0 && Cabbage_location == 0 && Goat_location == 1)"
	}
	then {
	  "Farmer_location = 1"
	}
    effects {
        ("They are all on the est bank of the river", 0.3)
    }
  }
  
  event(The farmer comes back to the ovest bank of the river) {
	if {
	  "Farmer_location == 1"
	  "(Wolf_location == 1 && Cabbage_location == 1 && Goat_location == 0) ||
	  (Wolf_location == 0 && Cabbage_location == 0 && Goat_location == 1)"
	}
	then {
	  "Farmer_location = 0"
	}
    effects {
        ("They are all on the est bank of the river", 0.3)
    }
  }
----

All identified events, but not the solution, are farmer's actions and all of them may cause the solution. Why?
The farmer requires a sequence of actions to solve its problem, and we cannot design that sequence, since it would mean to solve the problem at design time. Instead the proposed knowledge is a sort of **brutal force attack** to the problem, as a consequence of having many events that may cause the solution.

Joshua requires 24 cycles to solve the problem. Each cycle is an attempt to check if the final event occurs, and running a cycle is possible **only if the previous cycle changed the state**.

[source]
----
        Outcome|   true|
         Cycles|     24|
   Queue's size|     31|
----

Looking at the full details of each cycle (please see the appendic) is recognizable the brutal force attack, due to the many foolish attempts.
Below the clean concatenation of events to the final event.

[source]
----
   Cycle|                                                          Cause|                                      Effect|               Outcome|
       1|        The farmer brings the goat to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
       6|           The farmer comes back to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
       7|     The farmer brings the cabbage to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      13|   The farmer brings the cabbage to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
      14|      The farmer brings the goat to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
      16|        The farmer brings the goat to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      17|        The farmer brings the wolf to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      22|           The farmer comes back to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
      24|        The farmer brings the goat to the est bank of the river|   They are all on the est bank of the river|                  true|
----

== User guide


=== How to write a knowledge

A knowledge is a list of events. Joshua provides a simple programming language of Joshua to write a knowledge, where an event is defined by  following structure:

[source, bash]
----
event(<arbitrary name>) {
	if {
	  "<mathematical equality>"
	}
	then {
    "<mathematical assignement>"
	}
  effects {
    ("<event name>", <weight>)
  }
}
----

For example:

[source, bash]
----
event(The farmer comes back to the ovest bank of the river) {
	if {
	  "Farmer_location == 1"
	  "(Wolf_location == 1 && Cabbage_location == 1 && Goat_location == 0) ||
	  (Wolf_location == 0 && Cabbage_location == 0 && Goat_location == 1)"
	}
	then {
	  "Farmer_location = 0"
	}
  effects {
        ("They are all on the est bank of the river", 0.3)
  }
}
----

=== How to use the Joshua API

Here an example of using Joshua API to solve the problem of "the farmer, the wolf, the goat and the cabbage".

[source, golang]
----
package main

import (
   "io/ioutil"
	"it/losangeles971/joshua/business/knowledge"
	"strings"
)

func main() {
   thefarmer, err := ioutil.ReadFile("thefarmer.joshua")
   if err != nil {
		panic(err)
	}
   s := knowledge.NewState()
	s.Add("Farmer_location", 0.0)
	s.Add("Wolf_location", 0.0)
	s.Add("Goat_location", 0.0)
	s.Add("Cabbage_location", 0.0)
	engine, err := knowledge.NewEngine(string(thefarmer), 100)
	if err != nil {
		panic(err)
	}
	solution := engine.IsItGoingToHappen(*s, "They are all on the est bank of the river")
	if solution.Err != nil {
		panic(err)
	}
	solution.PrintChain()
	solution.PrintSummary()
}
----

=== How to use the Joshua CLI

The CLI is really simple and includes an help:

[source, shell]
----
$ ./joshua.exe --help
joshua

Usage:
  joshua [flags]

Flags:
  -d, --data string        initial state
  -h, --help               help for joshua
  -k, --knowledge string   knowledge file
  -m, --max-cycles int     maximum number of cycles (default 100) (default 100)
  -s, --success string     final event
----

Here an example to run Joshua over the problem of "the farmer, the wolf, the goat and the cabbage".

[source, shell]
----
$ ./joshua.exe -d .resources/thefarmer.yml -k .resources/thefarmer.joshua -s "They are all on the est bank of the river"
   Cycle|                                                          Cause|                                      Effect|               Outcome|
      13|   The farmer brings the cabbage to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
       1|        The farmer brings the goat to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      22|      The farmer brings the goat to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
       6|           The farmer comes back to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
       7|     The farmer brings the cabbage to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      14|     The farmer brings the cabbage to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      16|        The farmer brings the wolf to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      23|     The farmer brings the cabbage to the est bank of the river|   They are all on the est bank of the river|   effect not happened|
      28|           The farmer comes back to the ovest bank of the river|   They are all on the est bank of the river|   effect not happened|
      30|        The farmer brings the goat to the est bank of the river|   They are all on the est bank of the river|                  true|
        Outcome|   true|
         Cycles|     30|
   Queue's size|     37|
----

<<<
== Appendix

=== The farmer, the wolf, the goat and the cabbage

Below the full queue produced by Joshua to solve the problem of "the farmer, the wolf, the goat and the cabbage".
[source,yaml]
----
queue:
    - path:
        - cause:
            id: The farmer brings the goat to the est bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: effect not happened
      executed: true
      input:
        vars:
            Cabbage_location: 0
            Farmer_location: 0
            Goat_location: 0
            Wolf_location: 0
      output:
        vars:
            Cabbage_location: 0
            Farmer_location: 1
            Goat_location: 1
            Wolf_location: 0
      outcome: effect not happened
      changed: true
      cycle: 1
    - path:
        - cause:
            id: The farmer comes back to the ovest bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: effect not happened
      executed: true
      input:
        vars:
            Cabbage_location: 0
            Farmer_location: 1
            Goat_location: 1
            Wolf_location: 0
      output:
        vars:
            Cabbage_location: 0
            Farmer_location: 0
            Goat_location: 1
            Wolf_location: 0
      outcome: effect not happened
      changed: true
      cycle: 6
    - path:
        - cause:
            id: The farmer brings the cabbage to the est bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: effect not happened
      executed: true
      input:
        vars:
            Cabbage_location: 0
            Farmer_location: 0
            Goat_location: 1
            Wolf_location: 0
      output:
        vars:
            Cabbage_location: 1
            Farmer_location: 1
            Goat_location: 1
            Wolf_location: 0
      outcome: effect not happened
      changed: true
      cycle: 7
    - path:
        - cause:
            id: The farmer brings the goat to the ovest bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: effect not happened
      executed: true
      input:
        vars:
            Cabbage_location: 1
            Farmer_location: 1
            Goat_location: 1
            Wolf_location: 0
      output:
        vars:
            Cabbage_location: 1
            Farmer_location: 0
            Goat_location: 0
            Wolf_location: 0
      outcome: effect not happened
      changed: true
      cycle: 14
    - path:
        - cause:
            id: The farmer brings the wolf to the est bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: effect not happened
      executed: true
      input:
        vars:
            Cabbage_location: 1
            Farmer_location: 0
            Goat_location: 0
            Wolf_location: 0
      output:
        vars:
            Cabbage_location: 1
            Farmer_location: 1
            Goat_location: 0
            Wolf_location: 1
      outcome: effect not happened
      changed: true
      cycle: 17
    - path:
        - cause:
            id: The farmer comes back to the ovest bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: effect not happened
      executed: true
      input:
        vars:
            Cabbage_location: 1
            Farmer_location: 1
            Goat_location: 0
            Wolf_location: 1
      output:
        vars:
            Cabbage_location: 1
            Farmer_location: 0
            Goat_location: 0
            Wolf_location: 1
      outcome: effect not happened
      changed: true
      cycle: 22
    - path:
        - cause:
            id: The farmer brings the goat to the est bank of the river
          effect:
            id: They are all on the est bank of the river
          outcome: "true"
      executed: true
      input:
        vars:
            Cabbage_location: 1
            Farmer_location: 0
            Goat_location: 0
            Wolf_location: 1
      output:
        vars:
            Cabbage_location: 1
            Farmer_location: 1
            Goat_location: 1
            Wolf_location: 1
      outcome: "true"
      changed: true
      cycle: 24
----

:sectnums!:


